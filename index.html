<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic YE Ball â€” Shake for Wisdom</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Inter:wght@300;400&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: #000;
            min-height: 100vh;
            overflow: hidden;
            color: #fff;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Header - positioned at TOP */
        .header {
            position: fixed;
            top: 25px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }

        .title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: clamp(1.8rem, 7vw, 3rem);
            letter-spacing: 0.15em;
            text-shadow: 0 0 40px rgba(138, 43, 226, 0.6);
            margin-bottom: 5px;
        }

        .subtitle {
            font-size: 0.7rem;
            letter-spacing: 0.3em;
            color: #666;
        }

        .shake-hint {
            display: none;
            font-size: 0.6rem;
            letter-spacing: 0.2em;
            color: rgba(138, 43, 226, 0.7);
            margin-top: 8px;
            animation: shake-pulse 2s ease-in-out infinite;
        }

        .shake-hint.visible {
            display: block;
        }

        @keyframes shake-pulse {
            0%, 100% { opacity: 0.5; transform: translateX(0); }
            25% { transform: translateX(-3px); }
            50% { opacity: 1; }
            75% { transform: translateX(3px); }
        }

        /* Quote display - centered on the orb */
        .quote-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 340px;
            height: 340px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 60px;
            text-align: center;
            pointer-events: none;
            z-index: 15;
        }

        .quote-text {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.8rem;
            line-height: 1.2;
            letter-spacing: 0.05em;
            color: #fff;
            text-shadow: 
                0 0 20px rgba(138, 43, 226, 0.9),
                0 0 40px rgba(138, 43, 226, 0.5),
                0 2px 4px rgba(0,0,0,0.8);
            opacity: 0;
            transform: scale(0.9);
            transition: all 0.6s ease;
        }

        .quote-text.visible {
            opacity: 1;
            transform: scale(1);
        }

        .quote-text.loading {
            opacity: 0.5;
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.3; transform: scale(0.95); }
            50% { opacity: 0.6; transform: scale(1); }
        }

        .quote-attr {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, 140px);
            font-size: 0.7rem;
            letter-spacing: 0.2em;
            color: rgba(255,255,255,0.5);
            opacity: 0;
            transition: opacity 0.5s ease 0.3s;
            z-index: 15;
            pointer-events: none;
        }

        .quote-attr.visible {
            opacity: 1;
        }

        /* Context badge */
        .context-badge {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, 170px);
            font-size: 0.55rem;
            letter-spacing: 0.15em;
            color: rgba(138, 43, 226, 0.6);
            text-transform: uppercase;
            opacity: 0;
            transition: opacity 0.5s ease 0.5s;
            z-index: 15;
            pointer-events: none;
        }

        .context-badge.visible {
            opacity: 1;
        }

        /* Input panel */
        .input-panel {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 500px;
            pointer-events: auto;
            z-index: 20;
        }

        .input-wrapper {
            background: rgba(10, 10, 20, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 20px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .input-wrapper:focus-within {
            border-color: rgba(138, 43, 226, 0.6);
            box-shadow: 0 0 40px rgba(138, 43, 226, 0.2);
        }

        .input-label {
            font-size: 0.65rem;
            letter-spacing: 0.25em;
            color: #666;
            margin-bottom: 10px;
            display: block;
        }

        .input-row {
            display: flex;
            gap: 10px;
        }

        input[type="text"] {
            flex: 1;
            padding: 15px;
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            background: rgba(255,255,255,0.05);
            border: none;
            border-radius: 10px;
            color: #fff;
            outline: none;
        }

        input[type="text"]::placeholder {
            color: #444;
        }

        .shake-btn {
            padding: 15px 25px;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1rem;
            letter-spacing: 0.1em;
            background: linear-gradient(135deg, #6a0dad, #4a0080);
            color: #fff;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            min-width: 120px;
        }

        .shake-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 30px rgba(138, 43, 226, 0.5);
        }

        .shake-btn.reset-mode {
            background: linear-gradient(135deg, #4a0080, #2a0050);
        }

        .hint {
            text-align: center;
            margin-top: 12px;
            font-size: 0.7rem;
            color: #444;
            letter-spacing: 0.1em;
        }

        /* Shake animation for the orb */
        @keyframes orb-shake {
            0%, 100% { transform: translateX(0) translateY(0); }
            10% { transform: translateX(-8px) translateY(-3px); }
            20% { transform: translateX(8px) translateY(3px); }
            30% { transform: translateX(-6px) translateY(-2px); }
            40% { transform: translateX(6px) translateY(2px); }
            50% { transform: translateX(-4px) translateY(-1px); }
            60% { transform: translateX(4px) translateY(1px); }
            70% { transform: translateX(-2px) translateY(0); }
            80% { transform: translateX(2px) translateY(0); }
            90% { transform: translateX(-1px) translateY(0); }
        }

        .orb-shaking {
            animation: orb-shake 0.6s ease-out;
        }

        /* Mobile */
        @media (max-width: 500px) {
            .input-row {
                flex-direction: column;
            }
            .quote-container {
                width: 280px;
                height: 280px;
                padding: 50px;
            }
            .quote-text {
                font-size: 1.5rem;
            }
            .quote-attr {
                transform: translate(-50%, 120px);
            }
            .context-badge {
                transform: translate(-50%, 145px);
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div class="header">
        <h1 class="title">MAGIC YE BALL</h1>
        <p class="subtitle">ASK YOUR QUESTION â€¢ SHAKE FOR WISDOM</p>
        <p class="shake-hint" id="shakeHint">ðŸ“± SHAKE YOUR PHONE!</p>
    </div>
    
    <div class="quote-container">
        <p class="quote-text visible" id="quoteText">ASK AND<br>YE SHALL<br>RECEIVE</p>
    </div>
    <p class="quote-attr" id="quoteAttr">â€” KANYE WEST</p>
    <p class="context-badge" id="contextBadge"></p>

    <div class="input-panel">
        <div class="input-wrapper">
            <label class="input-label">WHAT TROUBLES YOU?</label>
            <div class="input-row">
                <input type="text" id="issueInput" placeholder="Speak your truth..." maxlength="200">
                <button class="shake-btn" id="shakeBtn" onclick="handleButtonClick()">PRESS (OR SHAKE DEVICE)</button>
            </div>
            <p class="hint" id="hintText">Press Enter, tap the orb, or shake your phone</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Three.js setup
        let scene, camera, renderer, sphere, uniforms, stars, nebulaMesh;
        let mouse = { x: 0.5, y: 0.5 };
        let targetMouse = { x: 0.5, y: 0.5 };
        let isHovering = false;
        let isActive = false;
        let time = 0;
        let shakeEnabled = false;
        let lastShakeTime = 0;

        // Background nebula shader
        const nebulaVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const nebulaFragmentShader = `
            uniform float uTime;
            uniform vec2 uMouse;
            varying vec2 vUv;
            
            // Simplex noise functions
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            
            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min(g.xyz, l.zxy);
                vec3 i2 = max(g.xyz, l.zxy);
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                float n_ = 0.142857142857;
                vec3 ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_);
                vec4 x = x_ * ns.x + ns.yyyy;
                vec4 y = y_ * ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4(x.xy, y.xy);
                vec4 b1 = vec4(x.zw, y.zw);
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                vec3 p0 = vec3(a0.xy, h.x);
                vec3 p1 = vec3(a0.zw, h.y);
                vec3 p2 = vec3(a1.xy, h.z);
                vec3 p3 = vec3(a1.zw, h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
            }

            float fbm(vec3 p) {
                float value = 0.0;
                float amplitude = 0.5;
                float frequency = 1.0;
                for (int i = 0; i < 5; i++) {
                    value += amplitude * snoise(p * frequency);
                    amplitude *= 0.5;
                    frequency *= 2.0;
                }
                return value;
            }
            
            void main() {
                vec2 uv = vUv;
                vec2 p = uv * 2.0 - 1.0;
                
                // Animated nebula clouds
                float t = uTime * 0.05;
                vec3 pos = vec3(p * 1.5, t);
                
                float n1 = fbm(pos + vec3(0.0, 0.0, t * 0.5));
                float n2 = fbm(pos * 2.0 + vec3(100.0, 0.0, t * 0.3));
                float n3 = fbm(pos * 0.5 + vec3(0.0, 100.0, t * 0.2));
                
                // Color palette - deep space purples and blues
                vec3 color1 = vec3(0.1, 0.0, 0.15);  // Deep purple
                vec3 color2 = vec3(0.05, 0.0, 0.1);  // Darker purple
                vec3 color3 = vec3(0.15, 0.05, 0.2); // Mid purple
                vec3 color4 = vec3(0.0, 0.02, 0.08); // Deep blue
                vec3 color5 = vec3(0.2, 0.1, 0.3);   // Bright purple accent
                
                // Mix colors based on noise
                vec3 color = color1;
                color = mix(color, color2, smoothstep(-0.5, 0.5, n1));
                color = mix(color, color3, smoothstep(-0.3, 0.7, n2) * 0.5);
                color = mix(color, color4, smoothstep(-0.2, 0.6, n3) * 0.3);
                
                // Add bright nebula wisps
                float wisp = smoothstep(0.3, 0.8, n1 * n2);
                color += color5 * wisp * 0.3;
                
                // Subtle mouse interaction - create a glow where mouse is
                float mouseDist = length(uv - uMouse);
                float mouseGlow = smoothstep(0.5, 0.0, mouseDist) * 0.15;
                color += vec3(0.3, 0.1, 0.5) * mouseGlow;
                
                // Vignette
                float vignette = 1.0 - length(p) * 0.4;
                color *= vignette;
                
                // Add some subtle grain
                float grain = (snoise(vec3(uv * 500.0, uTime)) * 0.5 + 0.5) * 0.03;
                color += grain;
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Orb vertex shader
        const vertexShader = `
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            uniform float uTime;
            uniform float uHover;
            uniform vec2 uMouse;
            uniform float uShake;
            
            void main() {
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);
                vPosition = position;
                
                vec3 pos = position;
                
                // Shake distortion
                if (uShake > 0.0) {
                    float shake = sin(uTime * 30.0) * uShake * 0.05;
                    pos.x += shake;
                    pos.y += cos(uTime * 25.0) * uShake * 0.03;
                }
                
                // Subtle vertex displacement on hover
                float dist = distance(uv, uMouse);
                float wave = sin(dist * 10.0 - uTime * 3.0) * 0.02 * uHover;
                pos += normal * wave;
                
                // Breathing effect
                float breath = sin(uTime * 0.5) * 0.01;
                pos *= 1.0 + breath;
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        // Orb fragment shader
        const fragmentShader = `
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            uniform float uTime;
            uniform float uHover;
            uniform float uActive;
            uniform float uShake;
            uniform vec2 uMouse;
            
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            
            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min(g.xyz, l.zxy);
                vec3 i2 = max(g.xyz, l.zxy);
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                float n_ = 0.142857142857;
                vec3 ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_);
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4(x.xy, y.xy);
                vec4 b1 = vec4(x.zw, y.zw);
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                vec3 p0 = vec3(a0.xy, h.x);
                vec3 p1 = vec3(a0.zw, h.y);
                vec3 p2 = vec3(a1.xy, h.z);
                vec3 p3 = vec3(a1.zw, h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
            }
            
            void main() {
                vec3 deepPurple = vec3(0.1, 0.0, 0.2);
                vec3 darkBlue = vec3(0.0, 0.0, 0.1);
                vec3 highlight = vec3(0.5, 0.2, 0.8);
                vec3 glow = vec3(0.6, 0.3, 1.0);
                
                vec3 viewDir = normalize(cameraPosition - vPosition);
                float fresnel = pow(1.0 - max(dot(viewDir, vNormal), 0.0), 3.0);
                
                float noise = snoise(vPosition * 3.0 + uTime * 0.2) * 0.5 + 0.5;
                float noise2 = snoise(vPosition * 5.0 - uTime * 0.3) * 0.5 + 0.5;
                
                float mouseDist = distance(vUv, uMouse);
                float ripple = sin(mouseDist * 20.0 - uTime * 4.0) * 0.5 + 0.5;
                ripple *= smoothstep(0.5, 0.0, mouseDist) * uHover;
                
                vec3 color = mix(deepPurple, darkBlue, noise);
                color = mix(color, highlight, noise2 * 0.3);
                color += fresnel * glow * (0.5 + uHover * 0.5);
                color += ripple * highlight * 0.5;
                
                // Active/shake glow
                float activeGlow = max(uActive, uShake);
                color += glow * activeGlow * 0.4 * (sin(uTime * 5.0) * 0.5 + 0.5);
                
                // Extra energy during shake
                if (uShake > 0.0) {
                    float energy = sin(uTime * 20.0) * 0.5 + 0.5;
                    color += vec3(0.8, 0.4, 1.0) * energy * uShake * 0.3;
                }
                
                vec3 lightDir = normalize(vec3(uMouse.x - 0.5, uMouse.y - 0.5, 1.0));
                float spec = pow(max(dot(reflect(-lightDir, vNormal), viewDir), 0.0), 32.0);
                color += vec3(1.0) * spec * 0.5 * (1.0 + uHover);
                
                float vignette = 1.0 - fresnel * 0.3;
                color *= vignette;
                
                gl_FragColor = vec4(color, 0.95);
            }
        `;

        function init() {
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 4;
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Background nebula plane
            const nebulaGeometry = new THREE.PlaneGeometry(20, 20);
            const nebulaMaterial = new THREE.ShaderMaterial({
                vertexShader: nebulaVertexShader,
                fragmentShader: nebulaFragmentShader,
                uniforms: {
                    uTime: { value: 0 },
                    uMouse: { value: new THREE.Vector2(0.5, 0.5) }
                }
            });
            nebulaMesh = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
            nebulaMesh.position.z = -5;
            scene.add(nebulaMesh);
            
            // Orb uniforms
            uniforms = {
                uTime: { value: 0 },
                uHover: { value: 0 },
                uActive: { value: 0 },
                uShake: { value: 0 },
                uMouse: { value: new THREE.Vector2(0.5, 0.5) }
            };
            
            // Orb
            const geometry = new THREE.SphereGeometry(1.3, 128, 128);
            const material = new THREE.ShaderMaterial({
                vertexShader,
                fragmentShader,
                uniforms,
                transparent: true
            });
            
            sphere = new THREE.Mesh(geometry, material);
            scene.add(sphere);
            
            // Stars
            createStars();
            
            // Events
            window.addEventListener('resize', onResize);
            window.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('click', onSphereClick);
            renderer.domElement.addEventListener('mouseenter', () => isHovering = true);
            renderer.domElement.addEventListener('mouseleave', () => isHovering = false);
            
            // Touch support
            renderer.domElement.addEventListener('touchmove', onTouchMove);
            renderer.domElement.addEventListener('touchstart', onSphereClick);
            
            // Initialize shake detection
            initShakeDetection();
            
            animate();
        }

        function createStars() {
            const starCount = 600;
            const positions = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);
            const twinkleOffsets = new Float32Array(starCount);
            
            for (let i = 0; i < starCount; i++) {
                const radius = 6 + Math.random() * 12;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                
                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi) - 5;
                
                sizes[i] = Math.random() < 0.1 ? 0.06 + Math.random() * 0.08 : 0.015 + Math.random() * 0.03;
                twinkleOffsets[i] = Math.random() * Math.PI * 2;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('twinkleOffset', new THREE.BufferAttribute(twinkleOffsets, 1));
            
            const starMaterial = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 } },
                vertexShader: `
                    attribute float size;
                    attribute float twinkleOffset;
                    varying float vTwinkle;
                    uniform float uTime;
                    
                    void main() {
                        vTwinkle = twinkleOffset;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        float twinkle = sin(uTime * 2.0 + twinkleOffset * 6.28) * 0.5 + 0.5;
                        float dynamicSize = size * (0.5 + twinkle * 0.5);
                        gl_PointSize = dynamicSize * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying float vTwinkle;
                    uniform float uTime;
                    
                    void main() {
                        float dist = length(gl_PointCoord - vec2(0.5));
                        if (dist > 0.5) discard;
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        float twinkle = sin(uTime * 3.0 + vTwinkle * 6.28) * 0.5 + 0.5;
                        vec3 color = mix(vec3(0.9, 0.95, 1.0), vec3(0.7, 0.8, 1.0), twinkle * 0.3);
                        color += vec3(0.1, 0.1, 0.2) * (1.0 - dist * 2.0);
                        gl_FragColor = vec4(color, alpha * 0.9);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            stars = new THREE.Points(geometry, starMaterial);
            scene.add(stars);
        }

        // Shake detection using DeviceMotion API
        function initShakeDetection() {
            if ('DeviceMotionEvent' in window) {
                // Check if we need permission (iOS 13+)
                if (typeof DeviceMotionEvent.requestPermission === 'function') {
                    // We'll request permission when user first interacts
                    document.body.addEventListener('click', requestMotionPermission, { once: true });
                    document.body.addEventListener('touchstart', requestMotionPermission, { once: true });
                } else {
                    // Android and older iOS - just add listener
                    enableShakeDetection();
                }
            }
        }

        function requestMotionPermission() {
            DeviceMotionEvent.requestPermission()
                .then(response => {
                    if (response === 'granted') {
                        enableShakeDetection();
                    }
                })
                .catch(console.error);
        }

        function enableShakeDetection() {
            shakeEnabled = true;
            document.getElementById('shakeHint').classList.add('visible');
            
            let lastX = 0, lastY = 0, lastZ = 0;
            let shakeThreshold = 15;
            let shakeCount = 0;
            let lastShakeCheck = 0;
            
            window.addEventListener('devicemotion', (e) => {
                const acc = e.accelerationIncludingGravity;
                if (!acc) return;
                
                const now = Date.now();
                if (now - lastShakeCheck < 100) return; // Throttle
                lastShakeCheck = now;
                
                const deltaX = Math.abs(acc.x - lastX);
                const deltaY = Math.abs(acc.y - lastY);
                const deltaZ = Math.abs(acc.z - lastZ);
                
                lastX = acc.x;
                lastY = acc.y;
                lastZ = acc.z;
                
                if (deltaX > shakeThreshold || deltaY > shakeThreshold || deltaZ > shakeThreshold) {
                    shakeCount++;
                    
                    // Visual feedback
                    uniforms.uShake.value = 1.0;
                    
                    // Trigger wisdom after sustained shake
                    if (shakeCount >= 3 && now - lastShakeTime > 2000) {
                        lastShakeTime = now;
                        shakeCount = 0;
                        triggerShakeWisdom();
                    }
                } else {
                    shakeCount = Math.max(0, shakeCount - 1);
                }
            });
        }

        function triggerShakeWisdom() {
            // Haptic feedback if available
            if ('vibrate' in navigator) {
                navigator.vibrate([100, 50, 100]);
            }
            
            seekWisdom();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(e) {
            targetMouse.x = e.clientX / window.innerWidth;
            targetMouse.y = 1 - (e.clientY / window.innerHeight);
        }

        function onTouchMove(e) {
            if (e.touches.length > 0) {
                targetMouse.x = e.touches[0].clientX / window.innerWidth;
                targetMouse.y = 1 - (e.touches[0].clientY / window.innerHeight);
            }
        }

        function onSphereClick(e) {
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const clickX = e.clientX || (e.touches && e.touches[0].clientX);
            const clickY = e.clientY || (e.touches && e.touches[0].clientY);
            const dist = Math.sqrt(Math.pow(clickX - centerX, 2) + Math.pow(clickY - centerY, 2));
            
            if (dist < 180) {
                seekWisdom();
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            time += 0.016;
            uniforms.uTime.value = time;
            
            // Update nebula background
            if (nebulaMesh && nebulaMesh.material.uniforms) {
                nebulaMesh.material.uniforms.uTime.value = time;
                nebulaMesh.material.uniforms.uMouse.value.set(mouse.x, mouse.y);
            }
            
            // Update stars
            if (stars && stars.material.uniforms) {
                stars.material.uniforms.uTime.value = time;
            }
            
            if (stars) {
                stars.rotation.y += 0.0001;
                stars.rotation.x += 0.00005;
            }
            
            // Smooth mouse
            mouse.x += (targetMouse.x - mouse.x) * 0.05;
            mouse.y += (targetMouse.y - mouse.y) * 0.05;
            uniforms.uMouse.value.set(mouse.x, mouse.y);
            
            // Hover state
            const targetHover = isHovering ? 1 : 0;
            uniforms.uHover.value += (targetHover - uniforms.uHover.value) * 0.1;
            
            // Active state
            const targetActive = isActive ? 1 : 0;
            uniforms.uActive.value += (targetActive - uniforms.uActive.value) * 0.1;
            
            // Shake decay
            uniforms.uShake.value *= 0.95;
            
            // Sphere rotation
            sphere.rotation.y += (mouse.x - 0.5) * 0.01;
            sphere.rotation.x += (mouse.y - 0.5) * 0.01;
            
            renderer.render(scene, camera);
        }

        // Wisdom logic
        let isSeeking = false;
        let isResetMode = false;

        function handleButtonClick() {
            if (isResetMode) {
                reset();
            } else {
                seekWisdom();
            }
        }

        function setButtonMode(resetMode) {
            const btn = document.getElementById('shakeBtn');
            isResetMode = resetMode;
            if (resetMode) {
                btn.textContent = 'ASK YE AGAIN';
                btn.classList.add('reset-mode');
            } else {
                btn.textContent = 'PRESS (OR SHAKE DEVICE)';
                btn.classList.remove('reset-mode');
            }
        }

        async function seekWisdom() {
            if (isSeeking) return;
            
            const issue = document.getElementById('issueInput').value.trim();
            if (!issue) {
                document.getElementById('issueInput').focus();
                // Shake the input to indicate it's required
                document.querySelector('.input-wrapper').style.animation = 'orb-shake 0.5s ease-out';
                setTimeout(() => {
                    document.querySelector('.input-wrapper').style.animation = '';
                }, 500);
                return;
            }

            isSeeking = true;
            isActive = true;
            uniforms.uShake.value = 1.0;
            
            const quoteText = document.getElementById('quoteText');
            const quoteAttr = document.getElementById('quoteAttr');
            const contextBadge = document.getElementById('contextBadge');
            quoteText.classList.remove('visible');
            quoteAttr.classList.remove('visible');
            contextBadge.classList.remove('visible');
            
            setTimeout(() => {
                quoteText.textContent = '...';
                quoteText.classList.add('loading');
                quoteText.classList.add('visible');
            }, 200);

            try {
                const response = await fetch('/api/wisdom', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ issue })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    await new Promise(resolve => setTimeout(resolve, 1200));
                    
                    quoteText.classList.remove('loading');
                    quoteText.textContent = `"${data.quote}"`;
                    quoteText.classList.add('visible');
                    quoteAttr.classList.add('visible');
                    
                    if (data.context && data.context !== 'general') {
                        contextBadge.textContent = `âœ§ ${data.context.toUpperCase()} âœ§`;
                        contextBadge.classList.add('visible');
                    }
                    
                    setButtonMode(true);
                } else {
                    throw new Error('API unavailable');
                }
                
            } catch (error) {
                const fallbacks = [
                    "I am God's vessel. But my greatest pain in life is that I will never be able to see myself perform live.",
                    "People always tell you 'Be humble.' When was the last time someone told you to be amazing?",
                    "Everything I'm not made me everything I am.",
                    "I feel like I'm too busy writing history to read it.",
                    "My greatest award is what I'm about to do.",
                    "I refuse to accept other people's ideas of happiness for me.",
                    "Would you believe in what you believe in if you were the only one who believed it?"
                ];
                const quote = fallbacks[Math.floor(Math.random() * fallbacks.length)];
                
                await new Promise(resolve => setTimeout(resolve, 1200));
                
                quoteText.classList.remove('loading');
                quoteText.textContent = `"${quote}"`;
                quoteText.classList.add('visible');
                quoteAttr.classList.add('visible');
                
                setButtonMode(true);
            }
        }

        function reset() {
            isSeeking = false;
            isActive = false;
            
            document.getElementById('quoteText').textContent = 'ASK AND\nYE SHALL\nRECEIVE';
            document.getElementById('quoteText').classList.add('visible');
            document.getElementById('quoteAttr').classList.remove('visible');
            document.getElementById('contextBadge').classList.remove('visible');
            document.getElementById('issueInput').value = '';
            setButtonMode(false);
        }

        document.getElementById('issueInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                seekWisdom();
            }
        });

        init();
    </script>
</body>
</html>
