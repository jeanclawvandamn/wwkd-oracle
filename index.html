<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magic YE Ball â€” Shake for Wisdom</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Inter:wght@300;400&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Inter', sans-serif;
            background: #000;
            min-height: 100vh;
            overflow: hidden;
            color: #fff;
        }
        #canvas-container {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }
        .header {
            position: fixed;
            top: 25px; left: 0;
            width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }
        .title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: clamp(1.8rem, 7vw, 3rem);
            letter-spacing: 0.15em;
            text-shadow: 0 0 40px rgba(138, 43, 226, 0.6);
            margin-bottom: 5px;
        }
        .subtitle {
            font-size: 0.7rem;
            letter-spacing: 0.3em;
            color: #666;
        }
        .shake-hint {
            display: none;
            font-size: 0.6rem;
            letter-spacing: 0.2em;
            color: rgba(138, 43, 226, 0.7);
            margin-top: 8px;
            animation: shake-pulse 2s ease-in-out infinite;
        }
        .shake-hint.visible { display: block; }
        @keyframes shake-pulse {
            0%, 100% { opacity: 0.5; transform: translateX(0); }
            25% { transform: translateX(-3px); }
            50% { opacity: 1; }
            75% { transform: translateX(3px); }
        }
        .quote-container {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 200px; height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            text-align: center;
            pointer-events: none;
            z-index: 15;
            transition: left 0.1s ease-out, top 0.1s ease-out;
        }
        .quote-text {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.8rem;
            line-height: 1.2;
            letter-spacing: 0.05em;
            color: #fff;
            text-shadow: 0 0 20px rgba(138, 43, 226, 0.9), 0 0 40px rgba(138, 43, 226, 0.5), 0 2px 4px rgba(0,0,0,0.8);
            opacity: 0;
            transform: scale(0.9);
            transition: all 0.6s ease;
        }
        .quote-text.visible { opacity: 1; transform: scale(1); }
        .quote-text.loading {
            opacity: 0.5;
            animation: pulse 1s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.3; transform: scale(0.95); }
            50% { opacity: 0.6; transform: scale(1); }
        }
        .quote-attr {
            position: fixed;
            transform: translate(-50%, 0);
            font-size: 0.7rem;
            letter-spacing: 0.2em;
            color: rgba(255,255,255,0.5);
            opacity: 0;
            transition: opacity 0.5s ease 0.3s, left 0.1s ease-out, top 0.1s ease-out;
            z-index: 15;
            pointer-events: none;
        }
        .quote-attr.visible { opacity: 1; }
        .context-badge {
            position: fixed;
            transform: translate(-50%, 0);
            font-size: 0.55rem;
            letter-spacing: 0.15em;
            color: rgba(138, 43, 226, 0.6);
            text-transform: uppercase;
            opacity: 0;
            transition: opacity 0.5s ease 0.5s, left 0.1s ease-out, top 0.1s ease-out;
            z-index: 15;
            pointer-events: none;
        }
        .context-badge.visible { opacity: 1; }
        .input-panel {
            position: fixed;
            bottom: 30px; left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 500px;
            pointer-events: auto;
            z-index: 20;
        }
        .input-wrapper {
            background: rgba(10, 10, 20, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 20px;
            padding: 20px;
            transition: all 0.3s ease;
        }
        .input-wrapper:focus-within {
            border-color: rgba(138, 43, 226, 0.6);
            box-shadow: 0 0 40px rgba(138, 43, 226, 0.2);
        }
        .input-label {
            font-size: 0.65rem;
            letter-spacing: 0.25em;
            color: #666;
            margin-bottom: 10px;
            display: block;
        }
        .input-row { display: flex; gap: 10px; }
        input[type="text"] {
            flex: 1;
            padding: 15px;
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            background: rgba(255,255,255,0.05);
            border: none;
            border-radius: 10px;
            color: #fff;
            outline: none;
        }
        input[type="text"]::placeholder { color: #444; }
        .shake-btn {
            padding: 15px 25px;
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1rem;
            letter-spacing: 0.1em;
            background: linear-gradient(135deg, #6a0dad, #4a0080);
            color: #fff;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            min-width: 120px;
        }
        .shake-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 30px rgba(138, 43, 226, 0.5);
        }
        .shake-btn.reset-mode {
            background: linear-gradient(135deg, #4a0080, #2a0050);
        }
        .hint {
            text-align: center;
            margin-top: 12px;
            font-size: 0.7rem;
            color: #444;
            letter-spacing: 0.1em;
        }
        @keyframes orb-shake {
            0%, 100% { transform: translateX(0) translateY(0); }
            10% { transform: translateX(-8px) translateY(-3px); }
            20% { transform: translateX(8px) translateY(3px); }
            30% { transform: translateX(-6px) translateY(-2px); }
            40% { transform: translateX(6px) translateY(2px); }
        }
        @media (max-width: 500px) {
            .input-row { flex-direction: column; }
            .quote-container { width: 280px; height: 280px; padding: 50px; }
            .quote-text { font-size: 1.5rem; }
            .quote-attr { transform: translate(-50%, 120px); }
            .context-badge { transform: translate(-50%, 145px); }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div class="header">
        <h1 class="title">MAGIC YE BALL</h1>
        <p class="subtitle">ASK YOUR QUESTION â€¢ SHAKE FOR WISDOM</p>
        <p class="shake-hint" id="shakeHint">ðŸ“± SHAKE YOUR PHONE!</p>
    </div>
    <div class="quote-container">
        <p class="quote-text visible" id="quoteText">ASK AND<br>YE SHALL<br>RECEIVE</p>
    </div>
    <p class="quote-attr" id="quoteAttr">â€” KANYE WEST</p>
    <p class="context-badge" id="contextBadge"></p>
    <div class="input-panel">
        <div class="input-wrapper">
            <label class="input-label">WHAT TROUBLES YOU?</label>
            <div class="input-row">
                <input type="text" id="issueInput" placeholder="Speak your truth..." maxlength="200">
                <button class="shake-btn" id="shakeBtn" onclick="handleButtonClick()">PRESS (OR SHAKE DEVICE)</button>
            </div>
            <p class="hint" id="hintText">Press Enter, tap the orb, or shake your phone</p>
        </div>
    </div>

    <!-- Kanye image for texture -->
    <img id="kanyeImg" crossorigin="anonymous" style="display:none" 
         src="/kanye_face.jpg">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, ballGroup, stars, nebulaMesh;
        let outerBall, innerLiquid, kanyeDisc;
        let mouse = { x: 0.5, y: 0.5 };
        let targetMouse = { x: 0.5, y: 0.5 };
        let velocity = { x: 0, y: 0 };
        let liquidOffset = { x: 0, y: 0 };
        let isHovering = false;
        let isActive = false;
        let time = 0;
        let shakeIntensity = 0;
        let lastShakeTime = 0;

        // Noise function for shaders
        const noiseGLSL = `
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i = floor(v + dot(v, C.yyy));
                vec3 x0 = v - i + dot(i, C.xxx);
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min(g.xyz, l.zxy);
                vec3 i2 = max(g.xyz, l.zxy);
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                float n_ = 0.142857142857;
                vec3 ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_);
                vec4 x = x_ * ns.x + ns.yyyy;
                vec4 y = y_ * ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4(x.xy, y.xy);
                vec4 b1 = vec4(x.zw, y.zw);
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                vec3 p0 = vec3(a0.xy, h.x);
                vec3 p1 = vec3(a0.zw, h.y);
                vec3 p2 = vec3(a1.xy, h.z);
                vec3 p3 = vec3(a1.zw, h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
            }
        `;

        // Purple liquid shader with sloshing
        const liquidVertexShader = `
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vPosition;
            uniform float uTime;
            uniform vec2 uLiquidOffset;
            uniform float uShake;
            
            ${noiseGLSL}
            
            void main() {
                vUv = uv;
                vNormal = normalize(normalMatrix * normal);
                
                vec3 pos = position;
                
                // Sloshing wave effect
                float slosh = sin(pos.x * 3.0 + uTime * 2.0 + uLiquidOffset.x * 5.0) * 0.03;
                slosh += sin(pos.y * 2.5 + uTime * 1.5 + uLiquidOffset.y * 5.0) * 0.03;
                slosh += cos(pos.z * 2.0 + uTime * 1.8) * 0.02;
                slosh *= (1.0 + uShake * 2.0);
                
                // Add noise for organic movement
                float noise = snoise(pos * 2.0 + uTime * 0.5) * 0.02 * (1.0 + uShake);
                
                pos += normal * (slosh + noise);
                
                vPosition = pos;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const liquidFragmentShader = `
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vPosition;
            uniform float uTime;
            uniform float uShake;
            
            ${noiseGLSL}
            
            void main() {
                // Deep purple liquid colors
                vec3 purple1 = vec3(0.3, 0.1, 0.5);
                vec3 purple2 = vec3(0.15, 0.05, 0.3);
                vec3 purple3 = vec3(0.5, 0.2, 0.7);
                vec3 highlight = vec3(0.7, 0.4, 1.0);
                
                // Animated noise for liquid movement
                float n1 = snoise(vPosition * 3.0 + uTime * 0.3) * 0.5 + 0.5;
                float n2 = snoise(vPosition * 5.0 - uTime * 0.4) * 0.5 + 0.5;
                
                vec3 color = mix(purple1, purple2, n1);
                color = mix(color, purple3, n2 * 0.3);
                
                // Fresnel glow
                vec3 viewDir = normalize(cameraPosition - vPosition);
                float fresnel = pow(1.0 - max(dot(viewDir, vNormal), 0.0), 2.0);
                color += highlight * fresnel * 0.4;
                
                // Specular highlights
                vec3 lightDir = normalize(vec3(0.5, 1.0, 0.5));
                float spec = pow(max(dot(reflect(-lightDir, vNormal), viewDir), 0.0), 16.0);
                color += vec3(1.0) * spec * 0.3;
                
                // Shake energy
                color += highlight * uShake * 0.3 * (sin(uTime * 10.0) * 0.5 + 0.5);
                
                gl_FragColor = vec4(color, 0.85);
            }
        `;

        // Outer glass ball shader
        const glassVertexShader = `
            varying vec3 vNormal;
            varying vec3 vPosition;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const glassFragmentShader = `
            varying vec3 vNormal;
            varying vec3 vPosition;
            uniform float uTime;
            
            void main() {
                vec3 viewDir = normalize(cameraPosition - vPosition);
                float fresnel = pow(1.0 - max(dot(viewDir, vNormal), 0.0), 3.0);
                
                // Solid black
                vec3 color = vec3(0.02, 0.02, 0.02);
                
                // Subtle edge highlight
                color += vec3(0.04, 0.04, 0.04) * fresnel;
                
                // Specular highlights for glossy 8-ball look
                vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                float spec = pow(max(dot(reflect(-lightDir, vNormal), viewDir), 0.0), 64.0);
                color += vec3(1.0) * spec * 0.7;
                
                // Secondary specular
                vec3 lightDir2 = normalize(vec3(-0.5, 0.8, 0.5));
                float spec2 = pow(max(dot(reflect(-lightDir2, vNormal), viewDir), 0.0), 32.0);
                color += vec3(0.9) * spec2 * 0.4;
                
                // Fully opaque black
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Nebula background
        const nebulaFragmentShader = `
            uniform float uTime;
            varying vec2 vUv;
            ${noiseGLSL}
            
            float fbm(vec3 p) {
                float v = 0.0, a = 0.5;
                for (int i = 0; i < 5; i++) {
                    v += a * snoise(p);
                    a *= 0.5;
                    p *= 2.0;
                }
                return v;
            }
            
            void main() {
                vec2 p = vUv * 2.0 - 1.0;
                float t = uTime * 0.03;
                
                float n1 = fbm(vec3(p * 1.5, t));
                float n2 = fbm(vec3(p * 2.0 + 100.0, t * 0.7));
                
                vec3 c1 = vec3(0.1, 0.0, 0.15);
                vec3 c2 = vec3(0.05, 0.0, 0.1);
                vec3 c3 = vec3(0.2, 0.1, 0.3);
                
                vec3 color = mix(c1, c2, smoothstep(-0.5, 0.5, n1));
                color += c3 * smoothstep(0.3, 0.8, n1 * n2) * 0.3;
                color *= 1.0 - length(p) * 0.3;
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 4;
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Nebula background
            const nebulaMat = new THREE.ShaderMaterial({
                vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                fragmentShader: nebulaFragmentShader,
                uniforms: { uTime: { value: 0 } }
            });
            nebulaMesh = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), nebulaMat);
            nebulaMesh.position.z = -5;
            scene.add(nebulaMesh);

            // Ball group
            ballGroup = new THREE.Group();
            scene.add(ballGroup);

            // Inner purple liquid sphere
            const liquidMat = new THREE.ShaderMaterial({
                vertexShader: liquidVertexShader,
                fragmentShader: liquidFragmentShader,
                uniforms: {
                    uTime: { value: 0 },
                    uLiquidOffset: { value: new THREE.Vector2(0, 0) },
                    uShake: { value: 0 }
                },
                transparent: true
            });
            innerLiquid = new THREE.Mesh(new THREE.SphereGeometry(1.15, 64, 64), liquidMat);
            ballGroup.add(innerLiquid);

            // Outer glass shell
            const glassMat = new THREE.ShaderMaterial({
                vertexShader: glassVertexShader,
                fragmentShader: glassFragmentShader,
                uniforms: { uTime: { value: 0 } },
                transparent: true,
                side: THREE.DoubleSide
            });
            outerBall = new THREE.Mesh(new THREE.SphereGeometry(1.3, 64, 64), glassMat);
            ballGroup.add(outerBall);

            // Purple liquid shader for porthole
            const portholeLiquidShader = `
                varying vec2 vUv;
                uniform float uTime;
                uniform vec2 uLiquidOffset;
                uniform float uShake;
                
                ${noiseGLSL}
                
                void main() {
                    vec2 uv = vUv;
                    vec2 center = vec2(0.5);
                    float dist = length(uv - center);
                    if (dist > 0.5) discard;
                    
                    // Sloshing offset
                    vec2 slosh = uv + uLiquidOffset * 0.3;
                    
                    // Animated purple liquid
                    float n1 = snoise(vec3(slosh * 4.0, uTime * 0.4)) * 0.5 + 0.5;
                    float n2 = snoise(vec3(slosh * 6.0 + 50.0, uTime * 0.3)) * 0.5 + 0.5;
                    
                    vec3 purple1 = vec3(0.4, 0.15, 0.6);
                    vec3 purple2 = vec3(0.2, 0.05, 0.35);
                    vec3 purple3 = vec3(0.55, 0.3, 0.8);
                    
                    vec3 color = mix(purple1, purple2, n1);
                    color = mix(color, purple3, n2 * 0.4);
                    
                    // Depth effect
                    color *= 1.0 - dist * 0.4;
                    
                    // Center highlight
                    color += vec3(0.15, 0.08, 0.25) * (1.0 - dist * 1.5);
                    
                    // Shake energy
                    color += vec3(0.3, 0.15, 0.5) * uShake * (sin(uTime * 10.0) * 0.5 + 0.5);
                    
                    gl_FragColor = vec4(color, 1.0);
                }
            `;
            
            // Create purple liquid disc for porthole
            const liquidDiscMat = new THREE.ShaderMaterial({
                vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                fragmentShader: portholeLiquidShader,
                uniforms: {
                    uTime: { value: 0 },
                    uLiquidOffset: { value: new THREE.Vector2(0, 0) },
                    uShake: { value: 0 }
                },
                side: THREE.DoubleSide
            });
            const liquidDisc = new THREE.Mesh(new THREE.CircleGeometry(0.52, 64), liquidDiscMat);
            liquidDisc.position.z = 1.32;
            ballGroup.add(liquidDisc);
            window.liquidDiscMat = liquidDiscMat;

            // Black rim around porthole (no face, just purple liquid visible)
            const rimMat = new THREE.MeshBasicMaterial({ color: 0x0a0a0a, side: THREE.DoubleSide });
            const rim = new THREE.Mesh(new THREE.RingGeometry(0.5, 0.58, 64), rimMat);
            rim.position.z = 1.31;
            ballGroup.add(rim);
            
            // Reference for tracking (use liquidDisc position)
            kanyeDisc = liquidDisc;

            // Stars
            createStars();

            // Events
            window.addEventListener('resize', onResize);
            window.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('click', onClick);
            renderer.domElement.addEventListener('touchstart', onClick);
            renderer.domElement.addEventListener('touchmove', onTouchMove);
            
            initShakeDetection();
            animate();
        }

        function createStars() {
            const count = 500;
            const positions = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) {
                const r = 8 + Math.random() * 10;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i*3+2] = r * Math.cos(phi) - 3;
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0xaaaaff, size: 0.03, transparent: true, opacity: 0.8 });
            stars = new THREE.Points(geo, mat);
            scene.add(stars);
        }

        // Gyro rotation values
        let gyroAlpha = 0, gyroBeta = 0, gyroGamma = 0;
        let gyroEnabled = false;

        function initShakeDetection() {
            // Request permissions for both motion and orientation
            if ('DeviceMotionEvent' in window || 'DeviceOrientationEvent' in window) {
                const requestPerms = async () => {
                    try {
                        if (typeof DeviceMotionEvent.requestPermission === 'function') {
                            await DeviceMotionEvent.requestPermission();
                        }
                        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                            await DeviceOrientationEvent.requestPermission();
                        }
                        enableGyroAndShake();
                    } catch (e) {
                        enableGyroAndShake();
                    }
                };
                document.body.addEventListener('click', requestPerms, { once: true });
                document.body.addEventListener('touchstart', requestPerms, { once: true });
                
                // Try enabling directly for non-iOS devices
                if (typeof DeviceOrientationEvent.requestPermission !== 'function') {
                    enableGyroAndShake();
                }
            }
        }

        function enableGyroAndShake() {
            document.getElementById('shakeHint').classList.add('visible');
            gyroEnabled = true;
            
            // Gyroscope for ball rotation
            window.addEventListener('deviceorientation', (e) => {
                if (e.beta !== null && e.gamma !== null) {
                    // Beta: front-back tilt (-180 to 180), Gamma: left-right tilt (-90 to 90)
                    gyroBeta = e.beta || 0;
                    gyroGamma = e.gamma || 0;
                    gyroAlpha = e.alpha || 0;
                }
            });
            
            // Shake detection
            let lastX = 0, lastY = 0, lastZ = 0, shakeCount = 0;
            window.addEventListener('devicemotion', (e) => {
                const acc = e.accelerationIncludingGravity;
                if (!acc) return;
                const d = Math.abs(acc.x - lastX) + Math.abs(acc.y - lastY) + Math.abs(acc.z - lastZ);
                lastX = acc.x; lastY = acc.y; lastZ = acc.z;
                
                if (d > 25) {
                    shakeIntensity = Math.min(1, shakeIntensity + 0.3);
                    shakeCount++;
                    if (shakeCount > 3 && Date.now() - lastShakeTime > 2000) {
                        lastShakeTime = Date.now();
                        shakeCount = 0;
                        if ('vibrate' in navigator) navigator.vibrate([100, 50, 100]);
                        seekWisdom();
                    }
                }
            });
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(e) {
            const newX = e.clientX / window.innerWidth;
            const newY = 1 - e.clientY / window.innerHeight;
            velocity.x = (newX - targetMouse.x) * 2;
            velocity.y = (newY - targetMouse.y) * 2;
            targetMouse.x = newX;
            targetMouse.y = newY;
        }

        function onTouchMove(e) {
            if (e.touches.length > 0) {
                const newX = e.touches[0].clientX / window.innerWidth;
                const newY = 1 - e.touches[0].clientY / window.innerHeight;
                velocity.x = (newX - targetMouse.x) * 3;
                velocity.y = (newY - targetMouse.y) * 3;
                targetMouse.x = newX;
                targetMouse.y = newY;
            }
        }

        function onClick(e) {
            const cx = window.innerWidth / 2, cy = window.innerHeight / 2;
            const x = e.clientX || (e.touches && e.touches[0].clientX);
            const y = e.clientY || (e.touches && e.touches[0].clientY);
            if (Math.sqrt((x-cx)**2 + (y-cy)**2) < 180) seekWisdom();
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            // Smooth mouse
            mouse.x += (targetMouse.x - mouse.x) * 0.08;
            mouse.y += (targetMouse.y - mouse.y) * 0.08;

            // Liquid physics - sloshing based on movement (contained within porthole)
            liquidOffset.x += velocity.x * 0.5;
            liquidOffset.y += velocity.y * 0.5;
            liquidOffset.x *= 0.92; // Damping
            liquidOffset.y *= 0.92;
            // Clamp to keep liquid visually contained
            liquidOffset.x = Math.max(-1.5, Math.min(1.5, liquidOffset.x));
            liquidOffset.y = Math.max(-1.5, Math.min(1.5, liquidOffset.y));
            velocity.x *= 0.88;
            velocity.y *= 0.88;

            // Update shaders
            if (nebulaMesh) nebulaMesh.material.uniforms.uTime.value = time;
            if (innerLiquid && innerLiquid.material && innerLiquid.material.uniforms) {
                innerLiquid.material.uniforms.uTime.value = time;
                innerLiquid.material.uniforms.uLiquidOffset.value.set(liquidOffset.x, liquidOffset.y);
                innerLiquid.material.uniforms.uShake.value = shakeIntensity;
            }
            if (window.liquidDiscMat && window.liquidDiscMat.uniforms) {
                window.liquidDiscMat.uniforms.uTime.value = time;
                window.liquidDiscMat.uniforms.uLiquidOffset.value.set(liquidOffset.x, liquidOffset.y);
                window.liquidDiscMat.uniforms.uShake.value = shakeIntensity;
            }
            if (outerBall) outerBall.material.uniforms.uTime.value = time;

            // Decay shake
            shakeIntensity *= 0.95;

            // Ball rotation - gyro or mouse
            if (ballGroup) {
                let targetRotY, targetRotX;
                
                if (gyroEnabled && (gyroBeta !== 0 || gyroGamma !== 0)) {
                    // Use gyroscope: gamma = left/right tilt, beta = front/back tilt
                    // Clamp rotation to keep porthole visible
                    targetRotY = Math.max(-0.6, Math.min(0.6, (gyroGamma / 90) * 0.8));
                    targetRotX = Math.max(-0.5, Math.min(0.5, ((gyroBeta - 45) / 90) * 0.6));
                    
                    // Add gyro movement to liquid sloshing
                    velocity.x += (targetRotY - ballGroup.rotation.y) * 0.3;
                    velocity.y += (targetRotX - ballGroup.rotation.x) * 0.3;
                } else {
                    // Use mouse
                    targetRotY = (mouse.x - 0.5) * 0.5;
                    targetRotX = (mouse.y - 0.5) * 0.3;
                }
                
                ballGroup.rotation.y += (targetRotY - ballGroup.rotation.y) * 0.08;
                ballGroup.rotation.x += (targetRotX - ballGroup.rotation.x) * 0.08;
            }

            // Stars rotation
            if (stars) stars.rotation.y += 0.0001;

            // Track quote text to window position
            if (kanyeDisc) {
                const windowPos = new THREE.Vector3();
                kanyeDisc.getWorldPosition(windowPos);
                windowPos.project(camera);
                
                const screenX = (windowPos.x * 0.5 + 0.5) * window.innerWidth;
                const screenY = (-windowPos.y * 0.5 + 0.5) * window.innerHeight;
                
                document.querySelector('.quote-container').style.left = screenX + 'px';
                document.querySelector('.quote-container').style.top = screenY + 'px';
                document.getElementById('quoteAttr').style.left = screenX + 'px';
                document.getElementById('quoteAttr').style.top = (screenY + 100) + 'px';
                document.getElementById('contextBadge').style.left = screenX + 'px';
                document.getElementById('contextBadge').style.top = (screenY + 125) + 'px';
            }

            renderer.render(scene, camera);
        }

        // Wisdom logic
        let isSeeking = false, isResetMode = false;

        function handleButtonClick() {
            if (isResetMode) reset();
            else seekWisdom();
        }

        function setButtonMode(resetMode) {
            const btn = document.getElementById('shakeBtn');
            isResetMode = resetMode;
            btn.textContent = resetMode ? 'ASK YE AGAIN' : 'PRESS (OR SHAKE DEVICE)';
            btn.classList.toggle('reset-mode', resetMode);
        }

        async function seekWisdom() {
            if (isSeeking) return;
            const issue = document.getElementById('issueInput').value.trim();
            if (!issue) {
                document.getElementById('issueInput').focus();
                return;
            }
            isSeeking = true;
            isActive = true;
            shakeIntensity = 1;
            
            const quoteText = document.getElementById('quoteText');
            const quoteAttr = document.getElementById('quoteAttr');
            const contextBadge = document.getElementById('contextBadge');
            
            quoteText.classList.remove('visible');
            quoteAttr.classList.remove('visible');
            contextBadge.classList.remove('visible');
            
            setTimeout(() => {
                quoteText.textContent = '...';
                quoteText.classList.add('loading', 'visible');
            }, 200);

            try {
                const res = await fetch('/api/wisdom', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ issue })
                });
                if (res.ok) {
                    const data = await res.json();
                    await new Promise(r => setTimeout(r, 1200));
                    quoteText.classList.remove('loading');
                    quoteText.textContent = `"${data.quote}"`;
                    quoteText.classList.add('visible');
                    quoteAttr.classList.add('visible');
                    if (data.context && data.context !== 'general') {
                        contextBadge.textContent = `âœ§ ${data.context.toUpperCase()} âœ§`;
                        contextBadge.classList.add('visible');
                    }
                    setButtonMode(true);
                } else throw new Error();
            } catch {
                const quotes = [
                    "I am God's vessel. But my greatest pain in life is that I will never be able to see myself perform live.",
                    "People always tell you 'Be humble.' When was the last time someone told you to be amazing?",
                    "Everything I'm not made me everything I am.",
                    "I feel like I'm too busy writing history to read it."
                ];
                await new Promise(r => setTimeout(r, 1200));
                quoteText.classList.remove('loading');
                quoteText.textContent = `"${quotes[Math.floor(Math.random() * quotes.length)]}"`;
                quoteText.classList.add('visible');
                quoteAttr.classList.add('visible');
                setButtonMode(true);
            }
        }

        function reset() {
            isSeeking = false;
            isActive = false;
            document.getElementById('quoteText').textContent = 'ASK AND\nYE SHALL\nRECEIVE';
            document.getElementById('quoteText').classList.add('visible');
            document.getElementById('quoteAttr').classList.remove('visible');
            document.getElementById('contextBadge').classList.remove('visible');
            document.getElementById('issueInput').value = '';
            setButtonMode(false);
        }

        document.getElementById('issueInput').addEventListener('keydown', e => {
            if (e.key === 'Enter') { e.preventDefault(); seekWisdom(); }
        });

        init();
    </script>
</body>
</html>
